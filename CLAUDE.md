# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## About This Project

Paid Python SDK - An all-in-one Business Engine for AI Agents that handles pricing, subscriptions, billing, and cost tracking.

**Important**: Most of this SDK is auto-generated by Fern from an OpenAPI spec. The primary areas for development work are:
- `src/paid/tracing/` - Custom OpenTelemetry-based cost tracking (custom code)
- `src/paid/client.py` - Main client with tracing integration (partially custom)

All other API client code (customers, agents, contacts, orders, etc.) is auto-generated and should not be modified directly.

## Development Commands

### Setup
```bash
poetry install
```

### Testing
```bash
# Run all tests
poetry run pytest -rP .

# Run specific test file
poetry run pytest tests/path/to/test_file.py
```

### Type Checking
```bash
poetry run mypy .
```

### Linting and Formatting
```bash
# Run ruff linter
poetry run ruff check .

# Format code with ruff
poetry run ruff format .
```

## Code Architecture

### Primary Development Areas

#### src/paid/tracing/ - OpenTelemetry Cost Tracking System

This is where most development work happens. The tracing system provides automatic cost tracking for AI provider API calls.

**tracing.py** (370 lines) - Core tracing implementation
- `_initialize_tracing()` - Sets up isolated TracerProvider with OTLP exporter to Paid backend
- `get_paid_tracer()` - Returns the isolated tracer instance
- `_trace_sync()` / `_trace_async()` - Core tracing logic for sync/async workflows
- `paid_tracing` decorator - Main decorator for wrapping user functions
- `generate_tracing_token()` / `set_tracing_token()` / `unset_tracing_token()` - Distributed tracing token management
- Context variables: `paid_external_customer_id_var`, `paid_external_agent_id_var`, `paid_token_var`, `paid_trace_id`

Key implementation details:
- Uses `SimpleSpanProcessor` instead of `BatchSpanProcessor` to avoid losing traces in environments like Airflow that terminate processes early
- Registers signal handlers (SIGINT, SIGTERM) and atexit hooks to flush traces on shutdown
- Creates spans with custom trace IDs for distributed tracing using `NonRecordingSpan` and `SpanContext`
- Context variables ensure customer/agent IDs propagate through nested calls

**signal.py** (55 lines) - Signal emission via OTEL
- `_signal()` - Sends events as OTEL spans with optional cost tracking association
- Validates that signals are sent within a tracing context
- Supports `enable_cost_tracing` flag to link signals with cost data from the same trace

**wrappers/** - AI Provider SDK Wrappers
Each wrapper intercepts AI provider calls and creates OTEL spans with cost data:
- **openai/** - Wraps OpenAI client (chat completions, embeddings, images, audio, etc.)
- **anthropic/** - Wraps Anthropic client (messages API)
- **mistral/** - Wraps Mistral client
- **gemini/** - Wraps Google Gemini client
- **bedrock/** - Wraps AWS Bedrock client
- **llamaindex/** - Wraps LlamaIndex operations
- **langchain/** - Callback handler for LangChain
- **openai_agents/** - Hook for OpenAI Agents SDK
- **utils.py** - Shared utilities (e.g., `get_audio_duration()` for audio file cost calculation using mutagen)

Wrapper pattern:
1. Wrap provider client class (e.g., `PaidOpenAI` wraps `OpenAI`)
2. Intercept API calls (chat completions, embeddings, etc.)
3. Extract usage data (tokens, units, etc.) from responses
4. Create OTEL span with cost attributes
5. Calculate costs based on usage and model pricing
6. Pass through original response unchanged

**autoinstrumentation.py** - Placeholder for future auto-instrumentation (currently empty)

#### src/paid/client.py - Main Client Classes

The `Paid` and `AsyncPaid` client classes integrate tracing with the auto-generated API clients:

- `initialize_tracing()` - User-facing method to set up tracing (calls `_initialize_tracing()`)
- `trace()` - User-facing method for callback-based tracing (calls `_trace_sync()` or `_trace_async()`)
- `signal()` - User-facing method for emitting signals (calls `_signal()`)
- Auto-generated resource clients: `customers`, `agents`, `contacts`, `orders`, `usage`

### Auto-Generated Code (Do Not Modify)

- **customers/**, **agents/**, **contacts/**, **orders/**, **usage/** - API resource clients
- **core/** - HTTP client, serialization, client wrapper utilities
- **types/** - Pydantic models for API requests/responses

### Key Design Patterns

1. **Isolated Tracing**: Uses a separate `TracerProvider` (`paid_tracer_provider`) to avoid interfering with user's existing OTEL setup. Never touches `trace.set_tracer_provider()`.

2. **Context Variables**: Uses `contextvars` (not thread-local storage) for async-safe propagation of customer IDs, agent IDs, and tokens through nested function calls.

3. **Distributed Tracing**: Supports linking traces across processes/machines:
   - `generate_tracing_token()` returns a unique trace ID
   - Pass token to `@paid_tracing(tracing_token=token)` or `Paid.trace(tracing_token=token)`
   - Creates `NonRecordingSpan` with custom `SpanContext` to link traces

4. **Dual API**: Two ways to add tracing:
   - Decorator: `@paid_tracing("customer_id", "agent_id")`
   - Callback: `client.trace(external_customer_id="...", fn=lambda: ...)`

5. **Sync/Async Support**: Both `_trace_sync()` and `_trace_async()` with identical logic. The `@paid_tracing` decorator auto-detects and wraps appropriately using `functools.wraps`.

6. **Graceful Degradation**: Wrappers are designed to pass through original responses even if cost tracking fails (logged but not raised).

## Development Guidelines

### What to Modify vs. What to Avoid

**✅ Safe to modify (custom code):**
- `src/paid/tracing/` - All tracing implementation
- `src/paid/client.py` - Only the tracing-related methods (`initialize_tracing()`, `trace()`, `signal()`)
- Test files
- Documentation

**❌ Do NOT modify (auto-generated by Fern):**
- `src/paid/customers/`, `agents/`, `contacts/`, `orders/`, `usage/` - API resource clients
- `src/paid/core/` - HTTP client, serialization utilities
- `src/paid/types/` - Pydantic models
- Most of `src/paid/client.py` - Constructor and resource client initialization

Changes to auto-generated code will be overwritten on next Fern generation.

### Adding New AI Provider Wrappers

When adding a wrapper for a new AI provider (e.g., Cohere, AI21):

1. Create new directory: `src/paid/tracing/wrappers/provider_name/`
2. Implement wrapper class that:
   - Wraps the provider's client class
   - Intercepts API calls (using `__getattr__` or direct method overrides)
   - Extracts usage data from responses (tokens, units, etc.)
   - Creates OTEL span with cost attributes using `get_paid_tracer().start_as_current_span()`
   - Calculates costs based on model pricing
   - Returns original response unchanged
3. Export wrapper in `src/paid/tracing/wrappers/__init__.py`
4. Follow existing wrapper patterns (see `openai/`, `anthropic/` for examples)

### Environment Variables

- `PAID_API_KEY` - API key for authentication (fallback if not passed to `Paid(token=...)`)
- `PAID_LOG_LEVEL` - Log level for tracing (DEBUG, INFO, WARNING, ERROR, CRITICAL), defaults to ERROR

### Testing

- Tests are in `tests/` directory
- Uses pytest with async support enabled (`asyncio_mode = "auto"`)
- Run with `poetry run pytest -rP .`

### Type Checking

- MyPy is configured with pydantic plugin
- External AI SDK dependencies (anthropic, openai, mistralai, etc.) are listed in `pyproject.toml` as dev dependencies with `ignore_missing_imports = true` since they're peer dependencies
- Run with `poetry run mypy .`

### OTEL Collector Endpoint

- Default: `https://collector.agentpaid.io:4318/v1/traces`
- Can be overridden in `initialize_tracing(collector_endpoint=...)`
- Uses OTLP HTTP exporter (not gRPC)
